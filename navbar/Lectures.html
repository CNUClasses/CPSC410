<section id="main_content" class="inner" style="height:100%;display:block;">
	<style>
	style_noborder{
	border-width: 0px;
	}
	.style_white {
	border-style: solid;
	border-width: 1px;
	background-color: #ffffff;
			}
	.style_emphasize {
	border-style: solid;
	border-width: 1px;
	background-color:#F4F2D8;;
			}
	</style>
<table style="width: 100%" class="style_noborder ">

	<tr>
		<td class="style_emphasize " colspan="3"> 
			<!-- <ul style="color: #cc0000">  -->
				
				<!-- <li>Office hours:<br>All office hours are virtual at <a href="https://meet.google.com/mgu-bodg-xhd?pli=1&authuser=1">this Google Meet link</a>. 
					<!-- I will also be available in person, in Luter 201-D, for MWF office hours. -->
				<!--	<ul>
						<li>MWF 2-2:55PM</li>
						<li>TTh  11AM-12:00PM</li>
						<li>Or drop me an <a href = "mailto: keith.perkins@cnu.edu">Email</a> and we can set up a something that works for you</li>
					</ul>
				</li>  
			</ul>-->
			<!-- <br><mark><b> C++ tutoring available in Hunter Creech Lab starting in February<br>
				 Tuesday and Thursday: 6 - 7:30PM  <br>
				 with <a href="mailto:paul.connolly@cnu.edu">Prof Paul Connolly</a></b></mark><br><br> -->

				
				Textbook: <a href=https://pages.cs.wisc.edu/~remzi/OSTEP>Operating Systems: Three Easy Pieces</a> by Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau.  Free online, you can also order a paper copy for a nominal fee.
				
				
		</td>

	</tr>
		<tr>
			<td class="style_white "><em><strong>Week</strong></em></td>
			<td class="style_white "><em><strong>Lectures/Readings</strong></em></td>
			<td class="style_white "><em><strong>Examples</strong></em></td>
		</tr>
		<tr>
			<td class="style_white "><em>1</em></td>
			<td class="style_white ">
				<strong>External content</strong><br>
				<strong><a href="https://www.coursera.org/learn/comparch "> OPTIONAL CONTENT!</a> An excellent (and Free) Computer Architecture course for those who are interested</strong><br><br>
				


				<strong>IDE Setup</strong><br>
				
				 <strong><a href="https://ubuntu.com/tutorials/how-to-run-ubuntu-desktop-on-a-virtual-machine-using-virtualbox#1-overview">Install Ubuntu Linux using Virtual Box</a>.  (Running a Mac with a M1 chip? Use <a href="https://mac.getutm.app/">UTM</a> instead of Virtual Box.  Its virtual machines are compatible with the M1 architecture). Be sure to give the linux VM as much memory and CPUs as you can</strong><BR>
					
				<!-- <strong><a href="https://github.com/CNUClasses/CPSC327/blob/master/content/Lectures/Steven_Utley_recommendations_for_Installing_Linux_on_VMWare.pdf" style="color: #cc0000"> Installing Linux on a VMWare virtual machine</a></strong>
				Dont want to partition your disk? No worries, one of your hero classmates wrote this handy guide, covers installing and configuring VMWare, installing linux on a virtual machine, and getting Eclipse CDT up and running.<br>     
				-->
				<strong><a href="https://linuxconfig.org/how-to-install-g-the-c-compiler-on-ubuntu-18-04-bionic-beaver-linux">Install g++ on Linux</a></strong><br />
				<strong><a href="https://cnuclasses.github.io/CPSC327/content/IDE_Setup/Eclipse_Setup_Ubuntu.pdf">Install Eclipse CDT on Linux</a></strong><br /><br>
	
				<strong>Quick Reference</strong><br>
			    <strong><a href="https://cnuclasses.github.io/CPSC327/content/Lectures/1_Cpp_reference.pdf"> C++ reference Card </a></strong><br>
				<strong><a href="https://cnuclasses.github.io/CPSC327/content/IDE_Setup/eclipse_shortcut_keys.pdf"> Eclipse Shortcut Keys I use </a></strong><br>
 
			   <br><strong>Linux and Git tutorials</strong><br>	
			   <strong><a href="http://www.ee.surrey.ac.uk/Teaching/Unix/">Linux tutorial</a></strong><br/>
            	<strong><a href="http://ryanstutorials.net/linuxtutorial/">Another Linux tutorial</a></strong><br/>
            	<strong><a href="http://rogerdudler.github.io/git-guide/">Git - the simple guide</a></strong><br/>
            	<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/1_1_Linux_and_Git.pdf">Git and Linux demo notes </a></strong><br>
 
				<br><strong>Lectures</strong><br>
            	<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/1_1_course_intro.pdf"> Course Intro </a></strong><br>
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/1_2_computer_architecture.pdf"> Computer Architecture</a></strong><br> 	 
				<br><strong>Please read</strong><br>
	    	    Chapter 2 : Introduction to Operating Systems<br>       	
            	
            </td>
			<td class="style_white ">
					<!--assign process load assignment-->
			</td>
		</tr>	
		<tr>
			<td class="style_white "><em>2</em></td>
			<td class="style_white ">
										
				  <strong>External content</strong><br>
				  <strong><a href="https://infonw.laurensstoop.nl/Introduction/OSworking.html"> Operating System Interrupts</a></strong> Interrupt types, CPU Execution mode (Supervisor or User), Interrupt process flow<br />	
				  		
				  <br><strong>Lectures</strong><br>
 				  <strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/PC_BOOT_SEQUENCE.pdf">Tangent: The PC boot process</a></strong><br> 				
				   <strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/2_OS_Overview.pdf"> Operating System Overview</a></strong><br> 
					<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/2_OS_OVERVIEW_ Intro_Virtual_Memory.pdf">Intro Paging example</a></strong><br>
Please read <br>
	    	         Chapter 4 : Processes<br>
	    	         Chapter 5 : Process API - fork(), wait(), exec() in unix plus a bit of linux command line<br>
					 Chapter 6 : Direct Execution<br>			   
          </td>
			<td class="style_white ">	
			</td>
		</tr>
 		<tr>
			<td class="style_white "><em>3</em></td>
			<td class="style_white ">
				<strong>External content</strong><br>	
				<strong><a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/signals.html">Optional: Introduction To Unix Signals Programming
				</a></strong><br> 			
				<strong><a href="https://www.geeksforgeeks.org/difference-fork-exec/">Difference between fork() and exec()</a></strong><br> 				
	  		     <br><strong>Lectures</strong><br>	
				   <strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/3_interrupts.pdf">Interrupts</a></strong><br> 

				 	
  			    <strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/3_process_description_and_control.pdf">Process Description and Control</a></strong><br> 
				  <!-- <strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/5_cpu_api_fork_wait_exec.pdf">fork(), wait(), exec() and a bit of terminal manipulation</a></strong><br>  -->
				 
				Please read Chapter 7: CPU Scheduling<br>
				and Chapter 8: The Multi-Level Feedback Queue<br>
				and Chapter 9: Scheduling: Proportional Share<br><br>
				NOTE:  We may circle back to Chapter 10: 'Multiprocessor Scheduling' at the end of the semester<BR>

			</td>
			<td class="style_white ">
				<strong><a href="https://github.com/CNUClasses/ctrl_c_signal_handler.git"> ctrl-c signal handler</a></strong> An application that registers to receive ctrl-c keyboard signals<br />
				<!-- <strong><a href="https://github.com/CNUClasses/ostep-code/tree/master/cpu-api"> Linux fork(), exec(), wait() examples</a></strong> See README.md for compilation and running<br /> -->

				<!--write a shell?-->
			</td>
		</tr>
 		<tr>
			<td class="style_white "><em>4</em></td>
			<td class="style_white ">
				<strong>External content</strong><br>	
				<strong><a href="https://www.cs.rutgers.edu/~pxk/416/notes/07-scheduling.html"> Process Scheduling Overview</a></strong> Very good!<br>	
	
				<br><strong>Lectures</strong><br>		
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/6_Scheduling.pdf">Process Scheduling</a></strong><br>
								
				
			Please read Chapter 13: The Abstraction: Address Space<br>
			Please see, Chapter 14, Interlude: Memory API, just this 1/2 page "Aside: Why No Memory is Leaked Once Your Process Exits"<br>
			and Chapter 15: Mechanism: Address Translation<br>
			and Chapter 16: Segmentation <br>   
			</td>
			<td class="style_white "> 
			<!-- assign process scheduler ( MLFQ improve?  make API all pointers and create custom lists and queues) -->
			</td>
			
		</tr>
		<tr>
			<td class="style_white "><em>5</em></td>
			<td class="style_white ">
			
				<strong>Lectures</strong><br>		
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/7_VirtualMem.pdf">Virtual Memory</a></strong><br>
				<!-- <strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/2_OS_OVERVIEW_ Intro_Virtual_Memory.pdf">Intro Paging example</a></strong><br> -->
	

				
					
				Please read:<br> 
				Chapter 18: Paging Introduction<br>
				<!-- really need to go over associative caches for TLB -->
				Chapter 19: Paging: Faster Translations (TLBs)<br>
				Chapter 20: Paging: Smaller Tables	<br>
			</td>
			<td class="style_white ">			
			</td>
		</tr>
	
		<tr>
			<td class="style_white "><em>6,7,8</em></td>
			<td class="style_white ">
				
				<strong>Lectures</strong><br>	
				<!-- <strong><a href="https://www.youtube.com/watch?v=WBh66fjb7EM&ab_channel=KeithPerkins">RECORDED: Translation Lookaside Buffer</a></strong>for Tuesday 2/20/24<br> -->
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/8_Paging.pdf">Paging</a></strong><br>
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/Page_Table_Example.pdf">Simple page table examples</a></strong><br>	
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/9_TLB.pdf">Translation Lookaside Buffer (TLB)</a></strong><br>  <br>
				
				<br><strong style="color: #cc0000">Test,3/13/25.  Includes everything above and projects 1. <BR>
					The test will be given to you on paper. <br>
					You may bring 1 sheet of paper with notes on both sides if you like. No other resources are allowed.</strong> <br> <br>
					
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/10_SmallerTables.pdf">Reducing the size of page tables</a></strong><br>  			
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/PagingandMultilevelpagetableexamples.pdf"> Examples: Multilevel Page tables </a></strong>  How to drastically reduce the size of page tables ( essential especially for 64 bit systems)<br>

						
				<!--Not for fall 23 <strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/11_MemPolicy.pdf"> Policy</a></strong>  Using the hard disk as virtual RAM.  Page replacement algorithms.<BR><br> -->
	
				
				 <!-- Please read Chapter 21: Beyond Physical Memory: Mechanisms<br> -->
				<!-- and Chapter 22: Beyond Physical Memory: Policies<br>--> -->
				
						
			</td>
			<td class="style_white ">			
			</td>
		</tr>
		<tr>
			<td class="style_white "><em>8,9</em></td>
			
			<td class="style_white ">
						
				<strong>External content</strong><br>	
				Please read Chapter 26: Concurrency: An Introduction<BR>
				<strong><a href="https://eli.thegreenplace.net/2016/c11-threads-affinity-and-hyperthreading/">(Advanced) C++11 threads, affinity and hyperthreading</a>Excellent! relates C++ threads to processor hardware</strong> <br><br> 
		<!--Threads, using and debugging in a C++ project. Timing of thread launch and its effects. The non deterministic nature of a multithreaded program. -->
			 <strong><a href="http://www.cplusplus.com/reference/atomic/"> Atomics </a></strong> Useful BUT can only synchronize 1 C++ operation at a time.<br>
		
				<!-- <strong style="color: #cc0000">NOTE: Projects that use threads require at least C++ 11 support.<br>
				  To enable it, click on <br>the project name->Properties-> 
				C/C++ Build->Settings->GCC C++ Compiler-> Dialect ->'Language Standard' dropdown.<br>
				  Then choose at least ISO C++11(-std=c++0x).  <br>
				  Make sure you include the pthread library under GCC C++ linker->Libraries.  Add pthread in the Libraries (-l) pane on the right.</strong><br>                                  
				<br>  -->
			<strong>Lectures</strong><br>
			<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/threads1.pdf"> Threads, an Introduction</a></strong><br>
					<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/thread_race_condition_critical_sections_atomics.pdf">Threads, Race conditions, critical sections, atomics</a></strong>A multithreaded introduction<br>
					
					Takeaways:<br>
					<ul>
						<li>Threaded applications can be proven incorrect, but not correct since you cant control the scheduler.  Therefore testing is not as helpful.  Your only defense is to write perfect code, to do this there are some rules to follow;<br>

						<li>If you start a thread (thread t1(fun)) you must wait for it to finish (t1.join())!</li>
						<li>Never, ever rely on knowledge of system behavior to predict thread run order! You cant tell! (see <a href="https://github.com/CNUClasses/Thread_Race_Condition.git">Thread_Race_Condition</a>) </li>
						<li>Learn to identify minimal critical sections.  You want them to be as small as possible since only 1 thread can be in the critical section at a time, the others block and wait.</li>
						<li>To identify critical sections, start by finding all variables that multiple threads can access.  This includes all globals, heap based variables that multiple threads are aware of, and all non-threadsafe API's used (like cout) </li>
						<li>Are these globals accessed by more than 1 thread? You probably have critical sections that need protection (synchronization).</li>
						<li>the exception to this rule is a shared variable that is only read,  never written.  BUT the very first time it's written it needs protection (synchronization) on every read and write</li>
						<li>Atomic classes are great, IFF you have a single line critical section.  For multiple lines, you need a mutex (coming next)</li>
						
					</ul>
					<!-- <strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/chapter_5_opencv_camera_bridge_view_HARD_race_condition_find_it.pdf"> A real world example race condition and critical section that is difficult to see</a></strong>  <br> -->
 	
	
		</td>
		<td class="style_white ">
			<strong><a href="https://github.com/CNUClasses/thread_simple.git"> Single thread demo</a></strong> Use disassembly view to see that each c++ statement is equivelent to multiple assembly instructions.  An interrupt can be serviced after any assembly instruction, which may be in the middle of a C++ instruction<br />
			<strong><a href="https://github.com/CNUClasses/thread_problem_atomic_solution.git"> Problems that threads can cause</a></strong> Running several threads, each reading and writing a global will cause unpredictable results. Demo using an atomic variable for a simple (but not generalizable to blocks of code>1 line) solution<br />
			<strong><a href="https://github.com/CNUClasses/Thread_Race_Condition.git"> Thread Race Condition</a></strong><br />
	
		</td>
		</tr>
<		<tr>
			<td class="style_white "><em>10,11</em></td>
			<td class="style_white ">	
				
					
				<strong>External content</strong><br>	
					Please read Chapter 28: Locks<BR>
					Please read Chapter 32, Common Concurrency Problems - pay attention to Deadlock and the section entitled 'Conditions for Deadlock' (see below)<br>
					Four conditions need to hold for a deadlock to occur:
					<ul>
							<li>Mutual exclusion: Threads claim exclusive control of resources 
							that they require (e.g., a thread grabs a lock).</li>
							<li>Hold-and-wait: Threads hold resources allocated to them (e.g., locks 
							that they have already acquired) while waiting for additional resources 
							(e.g., locks that they wish to acquire).</li>
							<li>No preemption: Resources (e.g., locks) cannot be forcibly removed 
							from threads that are holding them.</li>
							<li>Circular wait: There exists a circular chain of threads such that each
							thread holds one or more resources (e.g., locks) that are being 
							requested by the next thread in the chain.</li>
					</ul>
	
					
				<strong>Lectures</strong><br>
						Mutexes<br>
						<ul>
							<li>Mutexes are almost certainly going to be global variables (they will NOT be local variables)</li>
							<li>Mutexes function as a traffic cop, they allow 1 thread in a critical section at a time(others threads are blocked)</li>
							<li>Prefer a lock_guard over a raw mutex since it automatically unlocks when it goes out of scope</li>
							<li>To use: Identify minimal critical sections, then wrap critical section with an auto unlocking lock_guard</li>
						</ul>
	
						<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/mutex_intro.pdf"> Mutex </a></strong> Lecture notes.<br>						 
						<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/Thread_Ticket_Agent_Slides.pdf" style="color: #00cc00"> Thread Ticket Agent Slides</a></strong> Goes with project to the right<br>						 
					
						<br><strong>Deadlock Rule of thumb:</strong> If you are using 2 or more synchronization objects, then you should always aquire them in the same order.  If you break this rule and some threads aquire in different order then your code is prone to deadlock.<br>
				
						<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/deadlock_intro.pdf"> Deadlock </a></strong> Lecture notes.<br> 
					
							
							<td class="style_white ">
				<strong><a href="https://github.com/CNUClasses/demo_producer_consumer_busywait.git" style="color: #00cc00"> Fix this non threadsafe code</a></strong>, here is the 
					<strong><a href="https://github.com/CNUClasses/demo_producer_consumer_busywait_solution.git" style="color: #00cc00">Solution</a></strong><br> 
				
				
				<strong><a href="https://github.com/CNUClasses/410_stop_threads.git"> Stopping a thread Cleanly</a></strong><br> 
				<strong><a href="https://github.com/CNUClasses/spinlock.git"> A spinlock</a></strong> DEMO Do not use! Works but spikes CPU usage for all threads waiting for the lock!  <br />
				 <strong><a href="https://github.com/CNUClasses/mutex_thread.git"> Mutexes to synchronize threads</a></strong> Using a mutex to synchronize critical sections (as in multiple lines of code).  <br />
				<strong><a href="https://github.com/CNUClasses/mutex_lock_guard_sleep_for_yield.git">mutex_lock_guard_sleep_for_yield    </a></strong> Using a lock_guard to autounlock a mutex once the guard goes out of scope.  Also how to yield a threads timeslice or sleep the amount of time defined by std::chrono..<br />	
				<strong><a href="https://github.com/CNUClasses/simple_deadlock.git"> Simple Deadlock examples</a></strong> Very simple examples of how deadlock can occur<br /> 
				<strong><a href="https://github.com/CNUClasses/8_Deadlock.git"> A slightly more complex deadlock example</a></strong> <br /> <br>	
				<!--VERY VALUABLE CODING DEMO FOR STUDENTS -->
					<!-- Day 1
					spent 2 lectures on forcing students to code thread ticket agent
					start with sequential solution  (deterministic ? always)
					then add threads (dont join have app crash)
					then add mutex (raw then lock)
					then lock guard
					then other mutexes (to increase concurrency)
					day 2
					changed report to be more general
					added synchronized theatre class where patrons go when they have bought a ticket
					talked about deadlock, usually occurs if have 2 sync objects A and B.  Thread 1 holds A and wants B.  Thread 2 holds B and wants A.  But can occure if you lock the same object twice in same thread without interveningunlock
					added a Theatre to ticket agent
					at their request put the mutex to protect entry and exit from theatre outside class, showed how that led to messy code and hard to use class
					showed where deadlock can occur in theatre if locking same mutex <twice-->
	
<!--				<strong ><a href="https://github.com/CNUClasses/s24_s1.git" style="color: #00cc00"> Section 1 (9:30am class) Thread ticket agent - in class lab </a></strong> Complete solution<br>  
				<strong ><a href="https://github.com/CNUClasses/s24_s2.git" style="color: #00cc00"> Section 2 (11am class) Thread ticket agent - in class lab </a></strong> Complete solution<br>  
				
				<!-- <strong ><a href="https://github.com/CNUClasses/ticket_agent_f23.git" style="color: #00cc00"> Thread ticket agent - in class lab Fall 23</a></strong> Partial Solution, CURRENTLY DEADLOCKS-will fix next class after deadlock lecture<br>  --> 
<!--				<strong ><a href="https://github.com/CNUClasses/12_thread_ticket_agent.git" style="color: #00cc00"> Thread ticket agent - in class lab</a></strong> Solution Spring23 (different than Fall23 solution since it was built based on spring 23 student s23)<br>-->
				<strong><a href="https://github.com/CNUClasses/410_recursive_mutex.git">Recursive_mutex    </a></strong> A locking object that can be recursively locked (as long as you have 1 unlock() for every lock()).  This added functionality typically makes it harder to keep track of locked regions when designing your application. <br />	
			
	
			</td>	
		</tr>

		<tr>
			<td class="style_white "><em>12,13</em></td>
			<td class="style_white ">
			
					 
			<strong>External content</strong><br>	
			Please read Chapter 30, Condition Variables<br><BR>
				<strong style="color: #00cc00">What if you want thread 1 to wait until thread 2 says go? <br>
					You cannot do this with just a mutex (you can do it ineffeciently with a busy wait though). Condition Variables solve this problem. </strong><br> 
			<strong><a href="http://en.cppreference.com/w/cpp/thread/condition_variable"> Condition Variables, definition and sample code article</a></strong> <br>									
	
				<strong><a href="https://baptiste-wicht.com/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html"> Recursive Locks portion only</a></strong> This guy writes excellent C++ tutorials<br>
				<br><strong>Lectures</strong><br>
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/Condition_Variables.pdf"> Condition Variables</a></strong> Demonstration slides<br>	
				<strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/producer_consumer.pdf"> Producer Consumer, A common programming task</a></strong> Outline and solution flow.<br><br>
				<a href="https://youtu.be/loyIxp8M5I8">RECORDED, Project 4 Walk thru, Its a direct application of the producer/consumer problem </a>Tuesday 4/15/25 lecture: <br>		
				<!-- what happens when notify_one called and not notify all -->
				<strong style="color: #cc0000">Test 2, 4/17/25.  Includes everything from previous test thru week 13 and project 3. 
					The test will be given to you on paper. <br>
					You may bring 1 sheet of paper with notes on both sides. No other resources are allowed. <br> 
					You should know;<br>
					-multilevel page tables<br>
 					-how to identify and protect critical sections in a multi threaded program<br>
					-how to maximize concurrency in a multithreaded program.  For examaple, given 2 unrelated critical sections, you can protect each with a different mutex, and thus have 2 different threads executing in each critical section at the same time.<br>
					-how to recognize and prevent deadlock<br>
					-how to use mutexes in an exception prone environment (use a lock_guard that automatically unlocks)<br>
				</strong> <br>  
			</td>
			<td class="style_white ">	
				
				<strong><a href="https://github.com/CNUClasses/Simple_Condition_Variable.git">Simple Condition Variables</a></strong>Ordering thread operations.  Signaling between threads using a mutex a condition variable and a unique_lock<br/> 				
				<strong><a href="https://github.com/CNUClasses/410_ConditionVar_Mutex.git">Simple Condition Variables</a></strong>>What happens when you do not put cv.wait(...) in a while loop. (BTW you must always put cv.wait(...) in a while loop!) <br/> 
				<strong><a href="https://github.com/CNUClasses/410_start_threads_using_condition_var.git">Making all threads start at the same time using Condition Variables</a></strong> 
				All threads wait but there is still a problem with synchronizing the cout and i<br/>
	
				<strong><a href="https://github.com/CNUClasses/410_Producer_Consumer.git"> Simple producer consumer problem. Producer signals consumer.</a></strong>Single Producer, Single Consumer: Producer produces as fast as it can and notifies consumer, consumer consumes as fast as it can. Demoes effecient 1 way thread communication. Consumer will exit when global variable bDone is true and global count, gCount, of produced objects is 0. Can have multiple consumers.<br>
				<strong><a href="https://github.com/CNUClasses/410_Producer_many_consumers.git"> Producer consumer problem using mutex and condition variables</a></strong> Single Producer, Multiple Consumers <br />
				
				<strong><a href="https://github.com/CNUClasses/410_Producer_Consumer_Back_And_Forth.git">Complex producer consumer problem, Producer signals consumer and vice versa</a></strong>Producer produces one then notifies consumer, consumer consumes one then notifies producer. Demoes effecient 2 way thread communications. Consumer will exit when global variable bDone is true and global count, gCount, of produced objects is 0. <br>				
	
			</td>	
		</tr>	
		<tr>
<!--			<td class="style_white "><em>14</em></td>
			<td class="style_white ">
				<strong style="color: #cc0000">Midterm 1 and Midterm 2 solutions on scholar</strong><br><br> 
	
				<strong style="color: #cc0000">Final Exam Schedule<BR>
				<!-- 9:30 am class- Friday  4/26, 8am-10:30am (2.5 hours long)<br>
				11:00 am class- Tuesday 4/30, 11am-1:30pm (2.5 hours long)<br> -->
<!--				Friday December 13, 8-10:30am<br>
				
				<br>
				Similar format to Midterms<br>
				The test will be given to you on paper. <br>
				You may bring 5 sheets of paper with notes on both sides. No other resources are allowed.<br> 
				<br>
				It's Comprehensive:<br>
				All course material is fair game<br><br>
				Topics:<br>
				Difference between cooperative and pre emptive multitasking OS's<br>
				Process scheduling, scheduling algorithms, metrics<br>
				Virtual memory, simple and multilevel page tables, TLB's (there will probably be a multilevel page table problem)<br>
				<!-- Policy (clock, FIFO, Optimal, Least Recently used, there will be at least one of these)<br> -->
	
<!--				There will be be at least 1 multithreaded problem to solve that requires some combination of threads, mutexes, condition variables, semaphores<br>
				There will probably be a question on deadlock<br>
				THATS IT FOR THE HINTS, GOOD LUCK!<BR></strong> <br>
				<br><strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/Semaphore.pdf"> Semaphores </a></strong>Think of semaphores as bouncers at a nightclub. There are a dedicated number of people that are allowed in the club at once. If the club is full no one is allowed to enter, but as soon as 
				one person leaves another person might enter. It's simply a way to limit the number of consumers for a specific resource. For example, to limit the number of simultaneous calls to a database in an application.Or to limit the number of widgets produced before stopping and waiting for a consumer to catch up.  
				BTW a mutex can be represented as a semaphore that only lets one thread in the protected critical section at a time.<br>
		
				<!-- <strong><a href="https://cnuclasses.github.io/CPSC410/content/Lectures/chap5_dining_philosophers.pdf"> Using semaphores to solve dining philosophers problem </a></strong>handwritten lecture notes<br> -->
		
<!--			</td>
			<td class="style_white ">	
				<br><strong><a href="https://github.com/CNUClasses/410_Semaphore_ConditionVar_Mutex_Thread_Producer_Consumer.git"> Single Producer, single consumer solution using semaphores</a></strong> Semaphore example<br /> 
				<!-- <strong><a href="https://github.com/CNUClasses/410_Semaphore_Dining_Philosophers.git">Dining philosophers solution using semaphores (requires below library project)</a></strong><br/> 
				<strong><a href="https://github.com/CNUClasses/410_Semaphore_Lib.git">Semaphore class library (inherently useful stuff should be placed in a library)</a></strong><br/>
 -->
<!--				</td>
			
			</tr>
	
	
-->
	</table>
    </section>  