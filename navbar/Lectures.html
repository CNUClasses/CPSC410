<section id="main_content" class="inner" style="height:100%;display:block;">
	<style>
	style_noborder{
	border-width: 0px;
	}
	.style_white {
	border-style: solid;
	border-width: 1px;
	background-color: #ffffff;
			}
	.style_emphasize {
	border-style: solid;
	border-width: 1px;
	background-color:#F4F2D8;;
			}
	</style>
<table style="width: 100%" class="style_noborder ">
	<!-- 
	<tr>
        <td class="style_emphasize " colspan="3">  

		<strong style="color: #cc0000">C++ Tutoring available at the Center for Academic Success, CNU Hall Suite 124.   After 6 pm please enter CNU Hall via card swipe through the courtyard.</strong><br>	
			<ul style="color: #cc0000">
				<li>Monday:  3 pm - 6 pm (Individual Tutoring)</li>
				<li>Wednesday:  3 pm - 6 pm (Individual Tutoring)</li>
				<li>Wednesday: 7 pm - 9 pm (Drop-In Tutoring - No appointment needed)</li>
			</ul>
		</strong> 
	</tr> -->
	<tr>
		<td class="style_emphasize " colspan="3"> 
			<ul style="color: #cc0000"> 
				<li>You can access Google Meet lectures by opening your Blackboard shell in a web browser then choose 'Online Lectures' and then click on the Google Meet link to join.  </li>
				<li>Office hours conducted through  <a href="https://meet.google.com/mgu-bodg-xhd?pli=1&authuser=1">Google Meet </a>
					<ul>
						<li>TTh 10:45-Noon</li>
						<li>W 9AM-1PM</li>
						<li>Or drop me an email and we can set up a virtual meet at the above link</li>
						</li>
					</ul>

					</li>
			</ul>
		</td>

	</tr>
		<tr>
			<td class="style_white "><em><strong>Week</strong></em></td>
			<td class="style_white "><em><strong>Lectures/Readings</strong></em></td>
			<td class="style_white "><em><strong>Examples</strong></em></td>
		</tr>
		<tr>
			<td class="style_white "><em>1</em></td>
			<td class="style_white ">
			
			    <strong><a href="https://github.com/CNUClasses/CPSC327/blob/master/content/Lectures/1_Cpp_reference.pdf"> C++ reference Card </a></strong><br>
				<strong><a href="https://github.com/CNUClasses/CPSC327/blob/master/content/IDE_Setup/eclipse_shortcut_keys.pdf"> Eclipse Shortcut Keys I use </a></strong><br>
				<strong><a href="https://www.freecodecamp.org/news/how-to-install-ubuntu-with-oracle-virtualbox"style="color: #cc0000">Install Ubuntu Linux on a Windows machine (should also work for Mac)</a>Be sure to give the linux VM as much memory and CPUs as you can<BR>
				
				<!-- <strong><a href="https://github.com/CNUClasses/CPSC327/blob/master/content/Lectures/Steven_Utley_recommendations_for_Installing_Linux_on_VMWare.pdf" style="color: #cc0000"> Installing Linux on a VMWare virtual machine</a></strong>
				Dont want to partition your disk? No worries, one of your hero classmates wrote this handy guide, covers installing and configuring VMWare, installing linux on a virtual machine, and getting Eclipse CDT up and running.<br>     
             -->
				<strong><a href="https://linuxconfig.org/how-to-install-g-the-c-compiler-on-ubuntu-18-04-bionic-beaver-linux">Install g++ on Ubuntu 18.04</a></strong><br />
				<strong><a href="https://github.com/CNUClasses/CPSC327/blob/master/content/IDE_Setup/Eclipse_Setup_Ubuntu.pdf">Install Eclipse CDT on Linux</a></strong><br /><br>
				
            	<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/2-A_simple_C_++_program.pdf">2-A simple C++ program</a></strong><br>
            	<strong><a href="http://www.ee.surrey.ac.uk/Teaching/Unix/">Linux tutorial</a></strong><br/>
            	<strong><a href="http://ryanstutorials.net/linuxtutorial/">Another Linux tutorial</a></strong><br/>
            	<strong><a href="http://rogerdudler.github.io/git-guide/">Git - the simple guide</a></strong><br/><br>

            	<!-- 1 lecture -->
            	<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/1_1_course_intro.pdf"> Course Intro </a></strong><br>
            	<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/1_1_Linux_and_Git.pdf">Git and Linux demo notes </a></strong><br>
            	<!-- 1.5 lecture -->
				<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/1_2_computer_architecture.pdf"> Computer Architecture</a></strong><br> 	 
				<strong><a href="https://www.coursera.org/learn/comparch "> OPTIONAL CONTENT!</a> An excellent (and Free) Computer Architecture course for those who are interested</strong><br> 
				
				Please read <br>
	    	         Chapter 2 : Introduction to Operating Systems<br>       	
            	
            </td>
			<td class="style_white ">
				<strong><a href="https://github.com/CNUClasses/1_gcc_demo.git"> GCC demo files</a></strong> See "2-A simple C++ program" for notes on demo<br />
				<!--assign process load assignment-->
			</td>
		</tr>	
		<tr>
			<td class="style_white "><em>2</em></td>
			<td class="style_white ">
				<!-- 0.25 lecture -->
  				<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/PC_Boot_Process.pdf">Tangent: The PC boot process</a></strong><br> 
 				<!-- 1 lecture -->			
				  <strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/2_OS_Overview.pdf"> Operating System Overview</a></strong><br> 
				  <strong><a href="http://faculty.salina.k-state.edu/tim/ossg/Introduction/OSworking.html"> Operating System Interrupts</a></strong> Interrupt types, CPU Execution mode (Supervisor or User), Interrupt process flow<br />	
				  <!-- 1.0 lecture -->		
				  <strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/3_interrupts.pdf">Interrupts</a></strong><br> 
		 
		    	Please read <br>
	    	         Chapter 4 : Processes<br>
	    	         Chapter 5 : Process API - fork(), wait(), exec() in unix plus a bit of linux command line<br>
					 Chapter 6 : Direct Execution<br>
	    	         <!--https://stackpointer.io/unix/linux-view-threads-process/536/    for PID TGID -->
  	    	     <br>

				   
          </td>
			<td class="style_white ">	
			</td>
		</tr>

		<tr>
			<td class="style_white "><em>3</em></td>
			<td class="style_white ">
				<!-- 1.5 lecture -->		
  			    <strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/3_process_description_and_control.pdf">Process Description and Control</a></strong><br> 
				<!-- .75 lecture -->				
				<strong><a href="https://www.geeksforgeeks.org/difference-fork-exec/">Difference between fork() and exec()</a></strong><br> 				
	  		    <strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/5_cpu_api_fork_wait_exec.pdf">fork(), wait(), exec() and a bit of terminal manipulation</a></strong><br> 
				
				Please read Chapter 7: CPU Scheduling<br>
				and Chapter 8: The Multi-Level Feedback Queue<br>
				and Chapter 9: Scheduling: Proportional Share<br><br>
				NOTE:  We may circle back to Chapter 10: 'Multiprocessor Scheduling' at the end of the semester<BR>

			</td>
			<td class="style_white ">
				<strong><a href="https://github.com/CNUClasses/ostep-code/tree/master/cpu-api"> Linux fork(), exec(), wait() examples</a></strong> See README.md for compilation and running<br />

				<!--write a shell?-->
 			</td>
		</tr>
<tr>
		<td class="style_white "><em>4</em></td>
		<td class="style_white ">
			<strong><a href="https://www.cs.rutgers.edu/~pxk/416/notes/07-scheduling.html"> Process Scheduling Overview</a></strong> Very good!<br>	

			<!-- 2.0 lecture -->		
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/6_Scheduling.pdf">Process Scheduling</a></strong><br> 
			
			<!-- 2.0 lecture -->	
			<!-- Handwritten scheduling examples and old notes-->
<!-- 				<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/410_scheduling1.pdf"> Process Scheduling 1</a></strong> handwritten lecture notes<br>
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/410_scheduling2.pdf"> Process Scheduling 2</a></strong> handwritten lecture notes<br>	
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/410_process_scheduling_3.pdf"> Process Scheduling 3</a></strong> handwritten lecture notes<br>
-->		  
		Please read Chapter 13: The Abstraction: Address Space<br>
		Near page 137, Chapter 14 just this 1/2 page "Aside: Why No Memory is Leaked Once Your Process Exits"<br>
		and Chapter 15: Mechanism: Address Translation<br>
		and Chapter 16: Segmentation <br>   
		</td>
		<td class="style_white ">
		<!-- assign process scheduler ( MLFQ improve?  make API all pointers and create custom lists and queues) -->
		 </td>
	</tr>
	<tr>
		<td class="style_white "><em>5</em></td>
		<td class="style_white ">
			
			<!-- 2.0 lecture -->	
			<!-- good but overly assembler and base bounds and stack based, plus 70 slides -->
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/7_VirtualMem.pdf">Virtual Memory</a></strong><br>
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/7_relativeaddressing_helper.pdf">Base and bounds, in class extemporaneous demo slides</a></strong><br>
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/8_Paging.pdf">Paging</a></strong><br>
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/Page_Table_Example.pdf">Simple page table examples</a></strong><br>

		
			 <!-- Handwritten memory examples and old notes -->
			 <!--<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/memory.pdf"> Memory </a>OK- shows history, fragmentation not very detailed </strong><br>
					<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/410_paging_segmentation2.pdf"> Paging odds and ends</a></strong> Good - How processes are stored in memory, TLB outline, Page sharing<br>
			 -->
			
			Please read:<br> 
			Chapter 18: Paging Introduction<br>
			<!-- really need to go over associative caches for TLB -->
			Chapter 19: Paging: Faster Translations (TLBs)<br>
			Chapter 20: Paging: Smaller Tables	<br>
		</td>
		<td class="style_white ">			
		</td>
	</tr>

	<tr>
		<td class="style_white "><em>6</em></td>
		<td class="style_white ">
			
			
			<!-- 21 slides - 1 lecture	-->	
			<!-- 27 slides - 1 lecture 	-->	
			
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/9_TLB.pdf">Translation Lookaside Buffer (TLB)</a></strong><br>  
			<!-- <strong><a href="https://drive.google.com/file/d/1OBNC1Dazh7LfU5Y-rhwhZF9ZpeEC_gYC/view?usp=sharing">VIDEO:TLB lecture </a></strong><br> -->
			
			
			 Please read Chapter 21: Beyond Physical Memory: Mechanisms<br>
			and Chapter 22: Beyond Physical Memory: Policies<br>
			
		</td>
		<td class="style_white ">			
		</td>
	</tr>

	<tr>
		<td class="style_white "><em>7</em></td>
		<td class="style_white ">
			<!-- 21 slides - 1 lecture	-->	
			<!-- 27 slides - 1 lecture 	-->	
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/10_SmallerTables.pdf">Reducing the size of page tables</a></strong><br>  
			
			<!-- handwritten notes, covered by below <strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/multilevel_page_table.pdf"> Examples: Multilevel Page tables </a></strong>  How to drastically reduce the size of page tables ( essential especially for 64 bit systems)<br> -->
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/PagingandMultilevelpagetableexamples.pdf"> Examples: Multilevel Page tables </a></strong>  How to drastically reduce the size of page tables ( essential especially for 64 bit systems)<br>
		
			<!-- <strong><a href="https://drive.google.com/file/d/1PwHBT9PEss2n1X8Y4UA7Q49NgQDmBgph/view?usp=sharing">VIDEO LECTURE:Multi level page tables</a></strong><br> -->
			
			<!-- <strong style="color: #cc0000">Test 1, 10/20/20.  Includes all  material through week 7 and projects 1, 2. </strong> <br>  -->
			</td>
		<td class="style_white ">			
		</td>
	</tr>
	<tr>
		<td class="style_white "><em>8</em></td>
		<td class="style_white ">				
			<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/11_MemPolicy.pdf"> Policy</a></strong>  Using the hard disk as virtual RAM.  Page replacement algorithms.<BR>
			<strong style="color: #cc0000">Test 1<br>
				 8:00AM section 3/16/21<br>
				 9:30AM section 3/23/21 (because of in class tornado drill)<br>

				  Includes all  above material and projects 1, 2. </strong> <br> 

			</td>
		<td class="style_white ">			
		</td>
	</tr>
	<tr>
		<td class="style_white "><em>9</em></td>
		Please read Chapter 26: Concurrency: An Introduction<BR>
		<td><strong><a href="https://eli.thegreenplace.net/2016/c11-threads-affinity-and-hyperthreading/">(Advanced) C++11 threads, affinity and hyperthreading</a>Excellent! relates C++ threads to processor hardware</strong> <br><br>
		<strong style="color: #cc0000">NOTE: Projects that use threads require at least C++ 11 support.<br>
			  To enable it, click on <br>the project name->Properties-> 
			C/C++ Build->Settings->GCC C++ Compiler-> Dialect ->'Language Standard' dropdown.<br>
			  Then choose at least ISO C++11(-std=c++0x).  <br>
			  Make sure you include the pthread library under GCC C++ linker->Libraries.  Add pthread in the Libraries (-l) pane on the right.</strong><br>                                  
			<br>
		<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/threads1.pdf"> Threads, an Introduction</a></strong>
		<!-- <strong><a href="https://drive.google.com/file/d/1f0f74ZwsT0SaYVEm2HdRct7tjH0SbGAl/view?usp=sharing">VIDEO 1</a> <BR><br> 
		Threads, using and debugging in a C++ project. Timing of thread launch and its effects. The non deterministic nature of a multithreaded program. <strong><a href="https://drive.google.com/file/d/1ApqMLIyV65WZmlRmGo82GPi9KtoupiYg/view?usp=sharing">VIDEO </a> <BR><br> 
		 -->

	</td>
	<td class="style_white ">
		<strong><a href="https://github.com/CNUClasses/thread_simple.git"> Single thread demo</a></strong> Use disassembly view to see that each c++ statement is equivelent to multiple assembly instructions.  An interrupt can be serviced after any assembly instruction, which may be in the middle of a C++ instruction<br />
	</td>
	</tr>
	
	<tr>
		<td class="style_white "><em>10</em></td>
		<td class="style_white ">
				<strong><a href="http://www.cplusplus.com/reference/atomic/"> Atomics </a></strong> Useful BUT can only synchronize 1 C++ operation at a time.<br>
				<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/thread_race_condition_critical_sections_atomics.pdf">Threads, Race conditions, critical sections, atomics</a></strong>A multithreaded introduction
				
				Takeaways:<br>
				<li>Threads - know how to set up your C++ project to use threads (compiler set to use C++ 11 minimum, add the pthread library).  See <a href="https://github.com/CNUClasses/CPSC327/blob/master/content/Lectures/Eclipse_Customizations.pdf" > Eclipse Customizations</a> for more info.</li>
				Threaded applications can be proven incorrect, but not correct since you cant control the scheduler.  Therefore testing is not as helpful.  Your only defense is to write perfect code, to do this there are some rules to follow. <br>
				Rigid Requirements!<br>
				<ul>
					<li>If you start a thread (thread t1(fun)) you must wait for it to finish (t1.join())!</li>
					<li>Never, ever rely on knowledge of system behavior to predict thread run order! You cant tell! (see <a href="https://github.com/CNUClasses/Thread_Race_Condition.git">Thread_Race_Condition</a>) </li>
					<li>Learn to identify minimal critical sections.  You want them to be as small as possible since only 1 thread can be in the critical section at a time, the others block and wait.</li>
					<li>To identify critical sections, start by finding all variables that multiple threads can access.  This includes all globals, heap based variables that multiple threads are aware of, and all non-threadsafe API's used (like cout) </li>
					<li>Are these globals accessed by more than 1 thread? You probably have critical sections that need protection (synchronization).</li>
					<li>the exception to this rule is a shared variable that is only read,  never written.  BUT the very first time it's written it needs protection (synchronization) on every read and write</li>
					<li>Atomic classes are great, IFF you have a single line critical section.  For multiple lines, you need a mutex (coming next)</li>
					
				</ul>
				<!-- <strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/chapter_5_opencv_camera_bridge_view_HARD_race_condition_find_it.pdf"> A real world example race condition and critical section that is difficult to see</a></strong>  <br> -->

		
		<td class="style_white ">
			<strong><a href="https://github.com/CNUClasses/thread_problem_atomic_solution.git"> Problems that threads can cause</a></strong> Running several threads, each reading and writing a global will cause unpredictable results. Demo using an atomic variable for a simple (but not generalizable to blocks of code>1 line) solution<br />
			<strong><a href="https://github.com/CNUClasses/Thread_Race_Condition.git"> Thread Race Condition</a></strong><br />
			
		</td>
		
	</tr>
	<tr>
		<td class="style_white "><em>11</em></td>
		<td class="style_white ">		
				Please read Chapter 28: Locks<BR>
					Mutexes<br>
					<ul>
						<li>Mutexes are almost certainly going to be global variables (they will NOT be local variables)</li>
						<li>Mutexes function as a traffic cop, they allow 1 thread in a critical section at a time(others threads are blocked)</li>
						<li>Prefer a lock_guard over a raw mutex since it automatically unlocks when it goes out of scope</li>
						<li>To use: Identify minimal critical sections, then wrap critical section with an auto unlocking lock_guard</li>
					</ul>

						<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/mutex_intro.pdf"> Mutex </a></strong> Lecture notes.<br>						 
						
						Please read Chapter 32, Common Concurrency Problems - pay attention to Deadlock and the section entitled 'Conditions for Deadlock' (see below)<br>
						Four conditions need to hold for a deadlock to occur:
						<ul>
							   <li>Mutual exclusion: Threads claim exclusive control of resources 
							  that they require (e.g., a thread grabs a lock).</li>
							  <li>Hold-and-wait: Threads hold resources allocated to them (e.g., locks 
							  that they have already acquired) while waiting for additional resources 
							  (e.g., locks that they wish to acquire).</li>
							  <li>No preemption: Resources (e.g., locks) cannot be forcibly removed 
							  from threads that are holding them.</li>
							  <li>Circular wait: There exists a circular chain of threads such that each
							  thread holds one or more resources (e.g., locks) that are being 
							  requested by the next thread in the chain.</li>
						</ul>
						<br><strong>Deadlock Rule of thumb:</strong> If you are using 2 or more synchronization objects, then you should always aquire them in the same order.  If you break this rule and some threads aquire in different order then your code is prone to deadlock.<br>
		
						<strong><a href="https://github.com/CNUClasses/CPSC410/blob/master/content/Lectures/deadlock_intro.pdf"> Deadlock </a></strong> Lecture notes.
						<!-- ARTICLE IS NO LONGER PUBLICLY AVAILABLE<strong><a href="http://www.drdobbs.com/tools/avoiding-classic-threading-problems/231000499"> Avoiding Classic Threading Problems</a></strong> ADVANCED DISCUSSION- Excellent article, dont worry about openMP and Intel Thread Checker<br> -->
		
		<td class="style_white ">
			<strong><a href="https://github.com/CNUClasses/410_stop_threads.git"> Stopping a thread Cleanly</a></strong><br> 
			<strong><a href="https://github.com/CNUClasses/spinlock.git"> A spinlock</a></strong> Do not use! Works but spikes CPU usage for all threads waiting for the lock!  <br />
			<strong><a href="https://github.com/CNUClasses/mutex_thread.git"> Mutexes to synchronize threads</a></strong> Using a mutex to synchronize critical sections (as in multiple lines of code).  <br />
			<strong><a href="https://github.com/CNUClasses/12_thread_ticket_agent.git"> Thread ticket agent demo</a></strong> Sequential verses concurrent solutions plus illustration of common mistakes<br> 
			<strong><a href="https://github.com/CNUClasses/mutex_lock_guard_sleep_for_yield.git">mutex_lock_guard_sleep_for_yield    </a></strong> Using a lock_guard to autounlock a mutex once the guard goes out of scope.  Also how to yield a threads timeslice or sleep the amount of time defined by std::chrono..<br />	
			<strong><a href="https://github.com/CNUClasses/410_recursive_mutex.git">Recursive_mutex    </a></strong> A locking object that can be recursively locked (as long as you have 1 unlock() for every lock()).  This added functionality typically makes it harder to keep track of locked regions when designing your application. <br />	
		
			<strong><a href="https://github.com/CNUClasses/simple_deadlock.git"> Simple Deadlock examples</a></strong> Very simple examples of how deadlock can occur<br /> 
			<strong><a href="https://github.com/CNUClasses/8_Deadlock.git"> A slightly more complex deadlock example</a></strong> <br /> <br>	

		</td>
		
		
	</tr>


	</table>
    </section>

    